// Generated by CIRCT firtool-1.62.1
// Standard header to adapt well known macros for register randomization.
`ifndef RANDOMIZE
  `ifdef RANDOMIZE_MEM_INIT
    `define RANDOMIZE
  `endif // RANDOMIZE_MEM_INIT
`endif // not def RANDOMIZE
`ifndef RANDOMIZE
  `ifdef RANDOMIZE_REG_INIT
    `define RANDOMIZE
  `endif // RANDOMIZE_REG_INIT
`endif // not def RANDOMIZE

// RANDOM may be set to an expression that produces a 32-bit random unsigned value.
`ifndef RANDOM
  `define RANDOM $random
`endif // not def RANDOM

// Users can define INIT_RANDOM as general code that gets injected into the
// initializer block for modules with registers.
`ifndef INIT_RANDOM
  `define INIT_RANDOM
`endif // not def INIT_RANDOM

// If using random initialization, you can also define RANDOMIZE_DELAY to
// customize the delay used, otherwise 0.002 is used.
`ifndef RANDOMIZE_DELAY
  `define RANDOMIZE_DELAY 0.002
`endif // not def RANDOMIZE_DELAY

// Define INIT_RANDOM_PROLOG_ for use in our modules below.
`ifndef INIT_RANDOM_PROLOG_
  `ifdef RANDOMIZE
    `ifdef VERILATOR
      `define INIT_RANDOM_PROLOG_ `INIT_RANDOM
    `else  // VERILATOR
      `define INIT_RANDOM_PROLOG_ `INIT_RANDOM #`RANDOMIZE_DELAY begin end
    `endif // VERILATOR
  `else  // RANDOMIZE
    `define INIT_RANDOM_PROLOG_
  `endif // RANDOMIZE
`endif // not def INIT_RANDOM_PROLOG_

// Include register initializers in init blocks unless synthesis is set
`ifndef SYNTHESIS
  `ifndef ENABLE_INITIAL_REG_
    `define ENABLE_INITIAL_REG_
  `endif // not def ENABLE_INITIAL_REG_
`endif // not def SYNTHESIS

// Include rmemory initializers in init blocks unless synthesis is set
`ifndef SYNTHESIS
  `ifndef ENABLE_INITIAL_MEM_
    `define ENABLE_INITIAL_MEM_
  `endif // not def ENABLE_INITIAL_MEM_
`endif // not def SYNTHESIS

module SYSCNT(
  output        auto_in_a_ready,
  input         auto_in_a_valid,
  input  [3:0]  auto_in_a_bits_opcode,
  input  [1:0]  auto_in_a_bits_size,
  input  [4:0]  auto_in_a_bits_source,
  input  [29:0] auto_in_a_bits_address,
  input  [7:0]  auto_in_a_bits_mask,
  input  [63:0] auto_in_a_bits_data,
  input         auto_in_d_ready,
  output        auto_in_d_valid,
  output [3:0]  auto_in_d_bits_opcode,
  output [1:0]  auto_in_d_bits_size,
  output [4:0]  auto_in_d_bits_source,
  output [63:0] auto_in_d_bits_data,
  input         rtc_clock,
  input         rtc_reset,
  input         bus_clock,
  input         bus_reset,
  input         io_update_en,
  input  [63:0] io_update_value,
  input         io_stop_en,
  output        io_time_valid,
  output [63:0] io_time_bits
);

  wire [63:0]      _timeasync_io_o_time_bits;
  wire             _inc_update_bus_chain_io_q;
  wire             _time_sw_update_bus_chain_io_q;
  wire             _time_sw_req_rtc_chain_io_q;
  wire             _freqidx_req_rtc_chain_io_q;
  wire             _stop_sync_chain_io_q;
  wire             _update_sync_chain_io_q;
  reg  [63:0]      time_0;
  reg  [63:0]      time_sw;
  reg              time_sw_req;
  reg  [2:0]       freqidx;
  reg              freqidx_req;
  reg              freqidx_req_rtc_1f;
  wire             inccfg_vld = _freqidx_req_rtc_chain_io_q & ~freqidx_req_rtc_1f;
  reg              time_req_rtc_1f;
  wire             time_req_rtc_ris = _time_sw_req_rtc_chain_io_q & ~time_req_rtc_1f;
  reg  [2:0]       incwidth_r;
  reg              inc_up_dis;
  wire             inczero = incwidth_r == 3'h0;
  wire             inc_update =
    inc_up_dis
    & (inczero
       | (inczero ? 8'h1 : time_0[7:0] & 8'((8'h1 << incwidth_r) - 8'h1)) == 8'h0);
  reg  [2:0]       incr_width_value;
  reg              time_en;
  wire             in_bits_read = auto_in_a_bits_opcode == 4'h4;
  wire             _out_T_1 = auto_in_a_bits_address[15:5] == 11'h5FF;
  wire             _out_T_7 = auto_in_a_bits_address[15:5] == 11'h600;
  wire             _out_wofireMux_T_2 = auto_in_a_valid & auto_in_d_ready & ~in_bits_read;
  wire [3:0]       _GEN = {{_out_T_1}, {_out_T_7}, {_out_T_7}, {_out_T_7}};
  wire [3:0][63:0] _GEN_0 =
    {{_timeasync_io_o_time_bits},
     {{63'h0, time_sw_req}},
     {{63'h0, freqidx_req}},
     {{61'h0, freqidx}}};
  always @(posedge rtc_clock or posedge rtc_reset) begin
    if (rtc_reset) begin
      time_0 <= 64'h0;
      freqidx_req_rtc_1f <= 1'h0;
      time_req_rtc_1f <= 1'h0;
      inc_up_dis <= 1'h0;
      incr_width_value <= 3'h0;
      time_en <= 1'h0;
    end
    else begin
      if (time_req_rtc_ris)
        time_0 <= time_sw;
      else if (_stop_sync_chain_io_q) begin
      end
      else if (_update_sync_chain_io_q)
        time_0 <= io_update_value;
      else
        time_0 <=
          64'(time_0 + {56'h0, 8'h1 << (inc_update ? incwidth_r : incr_width_value)});
      freqidx_req_rtc_1f <= _freqidx_req_rtc_chain_io_q;
      time_req_rtc_1f <= _time_sw_req_rtc_chain_io_q;
      inc_up_dis <= inccfg_vld | ~inc_update & inc_up_dis;
      if (inc_update)
        incr_width_value <= incwidth_r;
      time_en <= ~_stop_sync_chain_io_q;
    end
  end // always @(posedge, posedge)
  always @(posedge bus_clock or posedge bus_reset) begin
    if (bus_reset) begin
      time_sw <= 64'h0;
      time_sw_req <= 1'h0;
      freqidx <= 3'h0;
      freqidx_req <= 1'h0;
    end
    else begin
      if (_out_wofireMux_T_2 & (&(auto_in_a_bits_address[4:3])) & _out_T_1
          & (&{{8{auto_in_a_bits_mask[7]}},
               {8{auto_in_a_bits_mask[6]}},
               {8{auto_in_a_bits_mask[5]}},
               {8{auto_in_a_bits_mask[4]}},
               {8{auto_in_a_bits_mask[3]}},
               {8{auto_in_a_bits_mask[2]}},
               {8{auto_in_a_bits_mask[1]}},
               {8{auto_in_a_bits_mask[0]}}}))
        time_sw <= auto_in_a_bits_data;
      if (_out_wofireMux_T_2 & auto_in_a_bits_address[4:3] == 2'h2 & _out_T_7
          & auto_in_a_bits_mask[0])
        time_sw_req <= auto_in_a_bits_data[0];
      else
        time_sw_req <= ~_time_sw_update_bus_chain_io_q & time_sw_req;
      if (_out_wofireMux_T_2 & auto_in_a_bits_address[4:3] == 2'h0 & _out_T_7
          & auto_in_a_bits_mask[0])
        freqidx <= auto_in_a_bits_data[2:0];
      if (_out_wofireMux_T_2 & auto_in_a_bits_address[4:3] == 2'h1 & _out_T_7
          & auto_in_a_bits_mask[0])
        freqidx_req <= auto_in_a_bits_data[0];
      else
        freqidx_req <= ~_inc_update_bus_chain_io_q & freqidx_req;
    end
  end // always @(posedge, posedge)
  always @(posedge rtc_clock) begin
    if (inccfg_vld)
      incwidth_r <= freqidx;
  end // always @(posedge)
  `ifdef ENABLE_INITIAL_REG_
    `ifdef FIRRTL_BEFORE_INITIAL
      `FIRRTL_BEFORE_INITIAL
    `endif // FIRRTL_BEFORE_INITIAL
    logic [31:0] _RANDOM[0:4];
    initial begin
      `ifdef INIT_RANDOM_PROLOG_
        `INIT_RANDOM_PROLOG_
      `endif // INIT_RANDOM_PROLOG_
      `ifdef RANDOMIZE_REG_INIT
        for (logic [2:0] i = 3'h0; i < 3'h5; i += 3'h1) begin
          _RANDOM[i] = `RANDOM;
        end
        time_0 = {_RANDOM[3'h0], _RANDOM[3'h1]};
        time_sw = {_RANDOM[3'h2], _RANDOM[3'h3]};
        time_sw_req = _RANDOM[3'h4][0];
        freqidx = _RANDOM[3'h4][3:1];
        freqidx_req = _RANDOM[3'h4][4];
        freqidx_req_rtc_1f = _RANDOM[3'h4][5];
        time_req_rtc_1f = _RANDOM[3'h4][6];
        incwidth_r = _RANDOM[3'h4][9:7];
        inc_up_dis = _RANDOM[3'h4][10];
        incr_width_value = _RANDOM[3'h4][13:11];
        time_en = _RANDOM[3'h4][14];
      `endif // RANDOMIZE_REG_INIT
      if (rtc_reset) begin
        time_0 = 64'h0;
        freqidx_req_rtc_1f = 1'h0;
        time_req_rtc_1f = 1'h0;
        inc_up_dis = 1'h0;
        incr_width_value = 3'h0;
        time_en = 1'h0;
      end
      if (bus_reset) begin
        time_sw = 64'h0;
        time_sw_req = 1'h0;
        freqidx = 3'h0;
        freqidx_req = 1'h0;
      end
    end // initial
    `ifdef FIRRTL_AFTER_INITIAL
      `FIRRTL_AFTER_INITIAL
    `endif // FIRRTL_AFTER_INITIAL
  `endif // ENABLE_INITIAL_REG_
  AsyncResetSynchronizerShiftReg_w1_d3_i0 update_sync_chain (
    .clock (rtc_clock),
    .reset (rtc_reset),
    .io_d  (io_update_en),
    .io_q  (_update_sync_chain_io_q)
  );
  AsyncResetSynchronizerShiftReg_w1_d3_i0 stop_sync_chain (
    .clock (rtc_clock),
    .reset (rtc_reset),
    .io_d  (io_stop_en),
    .io_q  (_stop_sync_chain_io_q)
  );
  AsyncResetSynchronizerShiftReg_w1_d3_i0 freqidx_req_rtc_chain (
    .clock (rtc_clock),
    .reset (rtc_reset),
    .io_d  (freqidx_req),
    .io_q  (_freqidx_req_rtc_chain_io_q)
  );
  AsyncResetSynchronizerShiftReg_w1_d3_i0 time_sw_req_rtc_chain (
    .clock (rtc_clock),
    .reset (rtc_reset),
    .io_d  (time_sw_req),
    .io_q  (_time_sw_req_rtc_chain_io_q)
  );
  AsyncResetSynchronizerShiftReg_w1_d3_i0 time_sw_update_bus_chain (
    .clock (bus_clock),
    .reset (bus_reset),
    .io_d  (time_req_rtc_ris),
    .io_q  (_time_sw_update_bus_chain_io_q)
  );
  AsyncResetSynchronizerShiftReg_w1_d3_i0 inc_update_bus_chain (
    .clock (bus_clock),
    .reset (bus_reset),
    .io_d  (inc_update),
    .io_q  (_inc_update_bus_chain_io_q)
  );
  TimeAsync timeasync (
    .clock           (bus_clock),
    .reset           (bus_reset),
    .io_i_time_valid (time_en),
    .io_i_time_bits  (time_0),
    .io_o_time_bits  (_timeasync_io_o_time_bits)
  );
  assign auto_in_a_ready = auto_in_d_ready;
  assign auto_in_d_valid = auto_in_a_valid;
  assign auto_in_d_bits_opcode = {3'h0, in_bits_read};
  assign auto_in_d_bits_size = auto_in_a_bits_size;
  assign auto_in_d_bits_source = auto_in_a_bits_source;
  assign auto_in_d_bits_data =
    _GEN[auto_in_a_bits_address[4:3]] ? _GEN_0[auto_in_a_bits_address[4:3]] : 64'h0;
  assign io_time_valid = time_en;
  assign io_time_bits = time_0;
endmodule

